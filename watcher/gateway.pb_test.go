// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gateway.proto

package watcher

import (
	context "context"
	"reflect"
	"testing"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
)

func TestGatewayInfo_Reset(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.Reset()
		})
	}
}

func TestGatewayInfo_String(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("GatewayInfo.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_ProtoMessage(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			g.ProtoMessage()
		})
	}
}

func TestGatewayInfo_Descriptor(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, got1 := g.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GatewayInfo.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("GatewayInfo.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestGatewayInfo_XXX_Unmarshal(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b []byte
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if err := m.XXX_Unmarshal(tt.args.b); (err != nil) != tt.wantErr {
				t.Errorf("GatewayInfo.XXX_Unmarshal() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestGatewayInfo_XXX_Marshal(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b             []byte
		deterministic bool
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []byte
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, err := m.XXX_Marshal(tt.args.b, tt.args.deterministic)
			if (err != nil) != tt.wantErr {
				t.Errorf("GatewayInfo.XXX_Marshal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GatewayInfo.XXX_Marshal() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_XXX_Merge(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		src proto.Message
	}
	tests := []struct {
		name   string
		fields fields
		args   args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_Merge(tt.args.src)
		})
	}
}

func TestGatewayInfo_XXX_Size(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.XXX_Size(); got != tt.want {
				t.Errorf("GatewayInfo.XXX_Size() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_XXX_DiscardUnknown(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_DiscardUnknown()
		})
	}
}

func TestGatewayInfo_GetGtwId(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetGtwId(); got != tt.want {
				t.Errorf("GatewayInfo.GetGtwId() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_GetRefId(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetRefId(); got != tt.want {
				t.Errorf("GatewayInfo.GetRefId() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_GetTimeCreated(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   int64
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetTimeCreated(); got != tt.want {
				t.Errorf("GatewayInfo.GetTimeCreated() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_GetActive(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetActive(); got != tt.want {
				t.Errorf("GatewayInfo.GetActive() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_GetRoutingUrl(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetRoutingUrl(); got != tt.want {
				t.Errorf("GatewayInfo.GetRoutingUrl() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGatewayInfo_GetZone(t *testing.T) {
	type fields struct {
		GtwId                string
		RefId                string
		TimeCreated          int64
		Active               bool
		RoutingUrl           string
		Zone                 string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GatewayInfo{
				GtwId:                tt.fields.GtwId,
				RefId:                tt.fields.RefId,
				TimeCreated:          tt.fields.TimeCreated,
				Active:               tt.fields.Active,
				RoutingUrl:           tt.fields.RoutingUrl,
				Zone:                 tt.fields.Zone,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetZone(); got != tt.want {
				t.Errorf("GatewayInfo.GetZone() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBadGatewayList_Reset(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.Reset()
		})
	}
}

func TestBadGatewayList_String(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("BadGatewayList.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBadGatewayList_ProtoMessage(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			b := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			b.ProtoMessage()
		})
	}
}

func TestBadGatewayList_Descriptor(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			b := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, got1 := b.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("BadGatewayList.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("BadGatewayList.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestBadGatewayList_XXX_Unmarshal(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b []byte
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if err := m.XXX_Unmarshal(tt.args.b); (err != nil) != tt.wantErr {
				t.Errorf("BadGatewayList.XXX_Unmarshal() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestBadGatewayList_XXX_Marshal(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b             []byte
		deterministic bool
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []byte
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, err := m.XXX_Marshal(tt.args.b, tt.args.deterministic)
			if (err != nil) != tt.wantErr {
				t.Errorf("BadGatewayList.XXX_Marshal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("BadGatewayList.XXX_Marshal() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBadGatewayList_XXX_Merge(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		src proto.Message
	}
	tests := []struct {
		name   string
		fields fields
		args   args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_Merge(tt.args.src)
		})
	}
}

func TestBadGatewayList_XXX_Size(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.XXX_Size(); got != tt.want {
				t.Errorf("BadGatewayList.XXX_Size() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBadGatewayList_XXX_DiscardUnknown(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_DiscardUnknown()
		})
	}
}

func TestBadGatewayList_GetList(t *testing.T) {
	type fields struct {
		List                 []string
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   []string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &BadGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetList(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("BadGatewayList.GetList() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGoodGatewayList_Reset(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.Reset()
		})
	}
}

func TestGoodGatewayList_String(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.String(); got != tt.want {
				t.Errorf("GoodGatewayList.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGoodGatewayList_ProtoMessage(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			g.ProtoMessage()
		})
	}
}

func TestGoodGatewayList_Descriptor(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
		want1  []int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, got1 := g.Descriptor()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GoodGatewayList.Descriptor() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("GoodGatewayList.Descriptor() got1 = %v, want %v", got1, tt.want1)
			}
		})
	}
}

func TestGoodGatewayList_XXX_Unmarshal(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b []byte
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if err := m.XXX_Unmarshal(tt.args.b); (err != nil) != tt.wantErr {
				t.Errorf("GoodGatewayList.XXX_Unmarshal() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestGoodGatewayList_XXX_Marshal(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		b             []byte
		deterministic bool
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []byte
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			got, err := m.XXX_Marshal(tt.args.b, tt.args.deterministic)
			if (err != nil) != tt.wantErr {
				t.Errorf("GoodGatewayList.XXX_Marshal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GoodGatewayList.XXX_Marshal() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGoodGatewayList_XXX_Merge(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	type args struct {
		src proto.Message
	}
	tests := []struct {
		name   string
		fields fields
		args   args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_Merge(tt.args.src)
		})
	}
}

func TestGoodGatewayList_XXX_Size(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.XXX_Size(); got != tt.want {
				t.Errorf("GoodGatewayList.XXX_Size() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGoodGatewayList_XXX_DiscardUnknown(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			m.XXX_DiscardUnknown()
		})
	}
}

func TestGoodGatewayList_GetList(t *testing.T) {
	type fields struct {
		List                 []*GatewayInfo
		XXX_NoUnkeyedLiteral struct{}
		XXX_unrecognized     []byte
		XXX_sizecache        int32
	}
	tests := []struct {
		name   string
		fields fields
		want   []*GatewayInfo
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &GoodGatewayList{
				List:                 tt.fields.List,
				XXX_NoUnkeyedLiteral: tt.fields.XXX_NoUnkeyedLiteral,
				XXX_unrecognized:     tt.fields.XXX_unrecognized,
				XXX_sizecache:        tt.fields.XXX_sizecache,
			}
			if got := m.GetList(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GoodGatewayList.GetList() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNewGatewayClient(t *testing.T) {
	type args struct {
		cc grpc.ClientConnInterface
	}
	tests := []struct {
		name string
		args args
		want GatewayClient
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewGatewayClient(tt.args.cc); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewGatewayClient() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_gatewayClient_GetList(t *testing.T) {
	type fields struct {
		cc grpc.ClientConnInterface
	}
	type args struct {
		ctx  context.Context
		in   *BadGatewayList
		opts []grpc.CallOption
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *GoodGatewayList
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &gatewayClient{
				cc: tt.fields.cc,
			}
			got, err := c.GetList(tt.args.ctx, tt.args.in, tt.args.opts...)
			if (err != nil) != tt.wantErr {
				t.Errorf("gatewayClient.GetList() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("gatewayClient.GetList() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestUnimplementedGatewayServer_GetList(t *testing.T) {
	type args struct {
		ctx context.Context
		req *BadGatewayList
	}
	tests := []struct {
		name    string
		u       *UnimplementedGatewayServer
		args    args
		want    *GoodGatewayList
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			u := &UnimplementedGatewayServer{}
			got, err := u.GetList(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("UnimplementedGatewayServer.GetList() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UnimplementedGatewayServer.GetList() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRegisterGatewayServer(t *testing.T) {
	type args struct {
		s   *grpc.Server
		srv GatewayServer
	}
	tests := []struct {
		name string
		args args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			RegisterGatewayServer(tt.args.s, tt.args.srv)
		})
	}
}

func Test_Gateway_GetList_Handler(t *testing.T) {
	type args struct {
		srv         interface{}
		ctx         context.Context
		dec         func(interface{}) error
		interceptor grpc.UnaryServerInterceptor
	}
	tests := []struct {
		name    string
		args    args
		want    interface{}
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := _Gateway_GetList_Handler(tt.args.srv, tt.args.ctx, tt.args.dec, tt.args.interceptor)
			if (err != nil) != tt.wantErr {
				t.Errorf("_Gateway_GetList_Handler() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("_Gateway_GetList_Handler() = %v, want %v", got, tt.want)
			}
		})
	}
}
